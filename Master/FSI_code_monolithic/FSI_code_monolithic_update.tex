\lstdefinelanguage{Python}{
 keywords={typeof, null, catch, switch, in, int, str, float, self},
 ndkeywords={boolean, throw, import},
 ndkeywords={return, class, if ,elif, endif, while, do, else, True, False , catch, def},
 ndkeywordstyle=\color{blue}\bfseries,
 identifierstyle=\color{black},
 sensitive=false,
 comment=[l]{\#},
 morecomment=[s]{/*}{*/},
 commentstyle=\color{purple}\ttfamily,
 stringstyle=\color{red}\ttfamily,
 backgroundcolor = \color{lightgray}
}

\chapter{FSI Implementation in FEniCS}
Here we will look at the implementation of the monolithic FSI Code in FENiCS. Not every part of the code will be handled here, but hopefully enough so that someone familiar with FEniCS could in short time implement the scheme.

\section{Mesh, mappings and stress tensors}
The mesh was made with Gmesh, with a clear straight boundary splitting the fluid and solid domains. This is converted to a xml file and loaded into FEniCS. 
\begin{lstlisting}[language=Python, basicstyle=\small]
mesh_file = Mesh("Mesh/fluid_new.xml")
\end{lstlisting}

The boundaries are defined using built in domain functions. We only here show the inlet where we specified where the spatial points are, and give it a mark value to be used when the Dirichlet conditions are set. This is also done using CellFunctions to define the fluid and structure domain. 

\begin{lstlisting}[language=Python,basicstyle=\small]
Inlet = AutoSubDomain(lambda x: "on_boundary" and near(x[0],0))
boundaries = FacetFunction("size_t",mesh_file)
Inlet.mark(boundaries, 3)
\end{lstlisting}


All the mappings are made with python functions, this is done so we can call the mappings later in the variational form.

\begin{lstlisting}[language=Python, basicstyle=\small]
def F_(d):
	return (Identity(len(d)) + grad(d))

def J_(d):
	return det(F_(d))
\end{lstlisting}

The stress tensors are also defined as functions to be used in the variational form.

\begin{lstlisting}[language=Python, basicstyle=\small]
def E(d):
	return 0.5*(F_(d).T*F_(d) - Identity(len(d)))

def S(d,lamda_s,mu_s):
    I = Identity(len(d))
    return 2*mu_s*E(d) + lamda_s*tr(E(d))*I

def Piola1(d,lamda_s,mu_s):
	return F_(d)*S(d,lamda_s,mu_s)
	
def sigma_f_u(u,d,mu_f):
    return  mu_f*(grad(u)*inv(F_(d)) + inv(F_(d)).T*grad(u).T)

def sigma_f_p(p, u):
    return -p*Identity(len(u))
    
\end{lstlisting}

\section{Variational form}

The variational form can be written directly into FEniCS. We write all the forms and add them together to make one big form to be calculated in the upcoming timeloop. We start by looking at the fluid variational form
\begin{lstlisting}[language=Python, basicstyle=\small]
J_theta = theta*J_(d_["n"]) + (1 - theta)*J_(d_["n-1"])

F_fluid_linear = rho_f/k*inner(J_theta*(v_["n"] - v_["n-1"]), psi)*dx_f

F_fluid_nonlinear =  Constant(theta)*rho_f*\
inner(J_(d_["n"])*grad(v_["n"])*inv(F_(d_["n"]))*v_["n"], psi)*dx_f

F_fluid_nonlinear += inner(J_(d_["n"])*sigma_f_p(p_["n"], d_["n"])*\
inv(F_(d_["n"])).T, grad(psi))*dx_f

F_fluid_nonlinear += Constant(theta)*inner(J_(d_["n"])\
*sigma_f_u(v_["n"], d_["n"], mu_f)*inv(F_(d_["n"])).T, grad(psi))*dx_f

F_fluid_nonlinear += Constant(1 - theta)*inner(J_(d_["n-1"])*\
sigma_f_u(v_["n-1"], d_["n-1"], mu_f)*inv(F_(d_["n-1"])).T, grad(psi))*dx_f

F_fluid_nonlinear += \
inner(div(J_(d_["n"])*inv(F_(d_["n"]))*v_["n"]), gamma)*dx_f

F_fluid_nonlinear += Constant(1 - theta)*rho_f*\
inner(J_(d_["n-1"])*grad(v_["n-1"])*inv(F_(d_["n-1"]))*v_["n-1"], psi)*dx_f

F_fluid_nonlinear -= rho_f*inner(J_(d_["n"])*\
grad(v_["n"])*inv(F_(d_["n"]))*((d_["n"]-d_["n-1"])/k), psi)*dx_f
\end{lstlisting}
where $dx_f$ is the fluid domain. The theta value choses the scheme we want. inv() gives the inverse of the matrix. 


Next is the solid variational form:
\begin{lstlisting}[language=Python, basicstyle=\small]
delta = 1E10
F_solid_linear = rho_s/k*inner(v_["n"] - v_["n-1"], psi)*dx_s +\
delta*(1/k)*inner(d_["n"] - d_["n-1"], phi)*dx_s -\
delta*inner(Constant(theta)*v_["n"] + Constant(1-theta)*v_["n-1"], phi)*dx_s

F_solid_nonlinear = inner(Piola1(Constant(theta)*d_["n"] +\
Constant(1 - theta)*d_["n-1"], lamda_s, mu_s), grad(psi))*dx_s
\end{lstlisting}

The weighed delta is talked about in section \ref{Discretization}

\section{NewtonSolver}
To solve a non-linear problem we need make a newton solver, taken from [Mikael kompendium]. F is derivated wrt to $dvp$ and is assembled to a matrix. -F is assembled as b and we solve until the residual is smaller than a give tolerance. There is also an if test which only assembles the Jacobian the first and tenth time. This reuses the Jacobian to improve speed, as we shall see later. Lastly the the mpi line is when the code is running in parallell that we only print out the values for one of the computational nodes.  
\begin{lstlisting}[language=Python, basicstyle=\small]
    Iter      = 0
    residual   = 1
    rel_res    = residual
    chi = TrialFunction(DVP)
    Jac = derivative(F, dvp_["n"], chi)

    while rel_res > rtol and residual > atol and Iter < max_it:
        if Iter == 0 or Iter == 10:
            A = assemble(Jac, tensor=A)#, keep_diagonal = True)
            A.ident_zeros()
            
        b = assemble(-F)
        
        [bc.apply(A, b, dvp_["n"].vector()) for bc in bcs]
        solve(A, dvp_res.vector(), b)
                   

        dvp_["n"].vector()[:] = dvp_["n"].vector()[:] + lmbda*dvp_res.vector()[:]
        [bc.apply(dvp_["n"].vector()) for bc in bcs]
        
        rel_res = norm(dvp_res, 'l2')
        residual = b.norm('l2')

        if MPI.rank(mpi_comm_world()) == 0:
            print "Newton iteration %d: r (atol) = %.3e (tol = %.3e), r (rel) = %.3e (tol = %.3e) " \
        % (Iter, residual, atol, rel_res, rtol)
        Iter += 1
\end{lstlisting}


\section{Timeloop}
In the time loop we call on the solver and update the functions $ v,d,p$ for each round. The counter value is used when we only want to take out values every certain number of time iterations.

\begin{lstlisting}[language=Python, basicstyle=\small]

while t <= T:
    print "Time t = %.5f" % t
    time_list.append(t)
    if t < 2:
        inlet.t = t;
    if t >= 2:
        inlet.t = 2;

    #Reset counters
    atol = 1e-6;rtol = 1e-6; max_it = 100; lmbda = 1.0;

    dvp = Newton_manual(F, dvp, bcs, atol, rtol, max_it, lmbda,dvp_res,VVQ)


    times = ["n-2", "n-1", "n"]
    for i, t_tmp in enumerate(times[:-1]):
   	dvp_[t_tmp].vector().zero()
    	dvp_[t_tmp].vector().axpy(1, dvp_[times[i+1]].vector())

    t += dt
    counter +=1
\end{lstlisting}


	