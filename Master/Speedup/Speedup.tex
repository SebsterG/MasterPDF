\chapter{CPU time reduction techniques}\label{runtime}
Computing FSI accurately is difficult not only because of the lack of stable partitioned schemes. It is also difficult because of the increase in runtime when modeling both fluid and structure, especially with monolithic schemes. When accuracy is needed in CFSI the number of cells can quickly become large. The matrices can become so large that the amount of computing time is not feasible.

In the Newton solver we have to assemble the Jacobian of the matrix, assemble the residual and solve for each iteration, until convergence is met. Working on this thesis the issue of runtime was certainly a problem, the wall clock time being days and weeks for a simulation to finish. 

This chapter describes the runtime reduction techniques made to the Newton solver. The point of this chapter is not to rigorously experiment with time improvement techniques, but merely to show what helped make simulation times bearable. Hopefully, helping others when employing a Newton solver. In fact, the ideas covered here are not new and has been implemented in Gabriel Balaban?s master thesis in 2012 \cite{Sciences2012}.

\section{Newton runtime profile}
In table \ref{no_opt} shows the runtime of the  FSI1 problem with no optimization. Listing the amount of time spent on Jacobian Assembly, residual assembly, and solve call. 
In table \ref{no_opt} it shows that the majority of time spent is in the assembly of the Jacobian. Therefore the effort will be spent on reducing the time spent on assembling the Jacobian. The next sections introduces two ways of improving time spent on assembling greatly. The first is reusing of the Jacobian and the second is employing a function in FENiCS called quadrature reduce. I will compare the timesaving techniques to table \ref{no_opt}.

\begin{table}[H]
\centering
\caption{Newton solver timed with no optimizations, $\bold{\Delta t = 0.5}$ }
\label{no_opt}
\begin{tabular}{|l|l|l|l|}
\hline
Method               & \textbf{Runtime {{[}}s{{]}}} & Runtime {{[}}\%{{]}} & \textbf{Calls} \\ \hline
Assembly of Jacobian & \textbf{60.7}                    & 94.4                     & \textbf{5}     \\ \hline
Assembly or residual & \textbf{0.6}                     & 0.9                      & \textbf{5}     \\ \hline
Solve                & \textbf{2.8}                     & 4.4                      & \textbf{5}     \\ \hline
Fulltime             & \textbf{64.3}                    & 100\%                    & -                \\ \hline
\end{tabular}
\end{table}

\section{Reusing the Jacobian}
As the time step is low in all the benchmarks, the effects of assembling the Jacobian for everytime step is assumed low. The trick therefore is to reuse the Jacobian. This is done by specifying reassembly for a certain number of iterations. When employed it was noticed that we needed a larger number of iterations to reach convergence, but the overall time of the Newton solver was much faster.
In table \ref{jac_reuse} the same FSI1 test is done with $\Delta t = 0.5$. Even with a timestep that is fairly large, we get great improvements in runtime (-74\%). The Jacobian assembles once meaning that at this timestep the Jacobian was calculated once and used again 9 times. What happens when we reuse the Jacobian, we have to iterate more times (9 times in this case) and as we can see the runtime in assembling the residual has increased by 50 \%. This is a much less costly process, so even when iterating more times we get a reduce in runtime.

\begin{table}[H]
\centering
\caption{Parts of the Newtonsolver timed with reuse of the jacobian run with $\bold{\Delta t = 0.5}$}
\label{jac_reuse}
\begin{tabular}{|l|l|l|l|}
\hline
Method & \textbf{Runtime {[}s{]}} & Runtime {[}\%{]} & \textbf{Calls} \\ \hline
Assembly of Jacobian & \textbf{11.5 (-80\%)} & 68.7 & \textbf{1 (-20\%)} \\ \hline
Assembly or residual & \textbf{0.9 (+50\%)} & 5.8 & \textbf{9 (+46\%)} \\ \hline
Solve & \textbf{4.2 (+50\%)} & 25.0 & \textbf{9 (+46\%)} \\ \hline
Fulltime & \textbf{16.8 (-74 \%)} & - & - \\ \hline
\end{tabular}
\end{table}


\section{Quadrature reduce}
Assembling of the Jacobian matrix with non-linear terms, induces a high number of quadrature points, leading to a dense matrix. When the accuracy of the Jacobian can be reduced, we can reduce the number of quadrature degree. This improves the runtime but reduces the accuracy leading to more iterations per time step. Reducing the quadrature degree can lead to numerical divergence of the system in some cases, but is of great help in many other cases.\newline

Table \ref{tab:quadreduce} shows that reducing the quadrature degree gives a 92 \% decrease in time spent assembling the Jacobian even with the same number of calls. The full time spent went down by 87 \%.
\begin{table}[H]
\centering
\caption{Parts of the Newtonsolver timed with quadrature reduxe run with FSI1 ,$\bold{\Delta t = 0.5}$}
\label{tab:quadreduce}
\begin{tabular}{|l|l|l|l|}
\hline
Method & \textbf{Runtime {[}s{]}} & Runtime {[}\%{]} & \textbf{Calls} \\ \hline
Assembly of Jacobian & \textbf{4.9 (-92\%)} & 60.3 & \textbf{5 (0\%)} \\ \hline
Assembly or residual & \textbf{0.5 (-17\%)} & 6.9 & \textbf{5 (0\%)} \\ \hline
Solve & \textbf{2.6 (-7\%)} & 31.9 & \textbf{5 (0\%)} \\ \hline
Fulltime & \textbf{8.2 (-87\%)} & - & - \\ \hline
\end{tabular}
\end{table}


\section{Summary of runtime improvement techniques}
Finally using both the reuse of Jacobian and the reduction of the quadrature. As we can see in table \ref{both_tech} the total runtime went down 89\%. In my work on this thesis these two techniques were used as often as possible. Both techniques worked with great success in the FSI2 and FSI3 case.

\begin{table}[H]
\centering
\caption{Newton solver timed with jacobian reuse and quadrature reduce run with $\bold{\Delta t = 0.5}$}
\label{both_tech}
\begin{tabular}{|l|l|l|l|}
\hline
Method & \textbf{Runtime {[}s{]}} & Runtime {[}\%{]} & \textbf{Calls} \\ \hline
Assembly of Jacobian & \textbf{1.2 (-98\%)} & 18.1 & \textbf{1 (-20\%)} \\ \hline
Assembly or residual & \textbf{0.9 (+50\%)} & 14.7 & \textbf{9 (+46\%)} \\ \hline
Solve & \textbf{4.4 (+57\%)} & 66.2 & \textbf{9 (+46\%)} \\ \hline
Fulltime & \textbf{6.6 (-89\%)} & - & - \\ \hline
\end{tabular}
\end{table}







